
\chapter{Algorithmes séquentiels}

	\marginicon{objectif}
	Avec ce chapitre, vous apprendrez à écrire un algorithme séquentiel pour
	résoudre un problème informatique. C'est aussi
	l'occasion de fixer la syntaxe du pseudo-code que nous
	allons utiliser. Nous commençons dans ce chapitre avec les algorithmes
	séquentiels qui sont de simples séquences de suites
	d'instructions. Les structures alternatives et
	répétitives seront vues dans les chapitres suivants.


	\section{Introduction}

		Supposons que nous voulions rédiger une marche
		à suivre détaillée qui explique comment additionner deux fractions. Une
		possibilité de l’écrire en langage «~naturel~» serait la suivante :

		\cadre{
		\begin{pseudo}
			\Stmt - Rechercher le dénominateur commun des deux fractions
			\Stmt - Mettre chaque fraction au même dénominateur
			\Stmt - Additionner les numérateurs des deux fractions,
			\Stmt \Indent ce qui donne le numérateur de la somme
			\Stmt - Simplifier la fraction obtenue
		\end{pseudo}
		}
		
		Cet algorithme, bien que résultant d’un effort
		d’explicitation, est encore très imprécis et risque fort de ne pas
		faciliter l’effort de programmation qui en suivrait. N’oublions pas
		qu’un ordinateur n’est qu’une machine dépourvue de toute intelligence
		et incapable de comprendre les sous-entendus qu’un être humain pourrait
		comprendre !

		De plus, les notions de dénominateur commun et
		de simplification de fraction, bien qu'élémentaires
		pour le cerveau, ne sont pas immédiates d'un point de
		vue algorithmique. Un algorithme proche d'un langage
		de programmation ne devrait mentionner que les opérations élémentaires
		de calcul telles que $+$, -, $*$, $/$.

		Ceci dit, afin d’être plus proche d’un
		programme écrit dans un langage compréhensible par l’ordinateur,
		l’algorithme ci-dessus pourrait s’écrire :

		\cadre{
		\begin{pseudo}
		\Stmt - Prendre connaissance du premier numérateur et du premier dénominateur ;
		\Stmt - Prendre connaissance du second numérateur et du second dénominateur ;
		\Stmt - Multiplier les deux dénominateurs pour obtenir le dénominateur commun ;
		\Stmt - Multiplier le premier numérateur par le second dénominateur
		\Stmt \Indent et le second numérateur par le premier dénominateur ;
		\Stmt - Additionner ces deux produits pour obtenir le numérateur du résultat ;
		\Stmt - Communiquer ce résultat ainsi que le dénominateur commun.
		\end{pseudo}
		}

		Notons encore que cet algorithme n’est pas le
		plus efficace pour ce type de problème. 
		Il vaudrait mieux utiliser le PPCM 
		(\textit{Plus Petit Commun Multiple}) 
		pour le calcul du dénominateur commun, mais la façon
		de calculer ce dernier serait très fastidieuse à rédiger en langage
		«~naturel~».

		On comprend bien au travers de cet exemple que
		le français n’est pas adapté à la description de problèmes au contenu
		mathématique ou scientifique. Le langage naturel est, en effet, un mode
		de représentation trop riche des algorithmes. Il faut comprendre par
		«~riche~», la présence de synonymes, de nombreux mots aux
		significations proches et voisines. L’utiliser amènerait probablement à
		une perte de temps (donc d’argent), et à des risques d’erreurs dans la
		conception des programmes. Il convient dès lors d’élaborer des méthodes
		de représentation plus rigoureuses (donc moins riches) mais nécessitant
		un effort moindre de programmation.

		Ceci dit, le français peut toujours être
		utilisé dans la formalisation d’une première approche de la résolution
		d’un problème devant être traduit ensuite en algorithme puis en
		programme.

	\section{Le pseudo-code}
	
		Les inconvénients de l’utilisation du français dans la représentation
		des algorithmes sont dus à la trop grande richesse de ce langage en
		comparaison à la pauvreté (mais aussi la rigueur) du langage compris
		par la machine. De plus, la lourdeur et la longueur des phrases
		risquent de rendre pénible la relecture et le travail d’élaboration des
		algorithmes. La solution consiste à édulcorer le langage naturel, d’une
		part en remplaçant les noms parfois fastidieux des objets sur lesquels
		portent des opérations par des mots (noms de variables) plus courts,
		d’autre part, en remplaçant les opérations elles-mêmes par des
		opérateurs symboliques suffisamment explicites. De plus, des structures
		types remplaceront les multiples possibilités linguistiques signifiant
		la même chose.

		\marginicon{definition}
		Le \textbf{pseudo-code} ou \textit{Langage de Description des
		Algorithmes} (LDA en abrégé) est un langage formel et symbolique
		utilisant :

		\begin{liste}
		\item
			des \textbf{noms symboliques} destinés à représenter les objets sur
			lesquels s’effectuent des actions ;
		\item
			des \textbf{opérateurs symboliques} ou des mots-clés traduisant les
			opérations primitives exécutables par un exécutant donné ;
		\item
			des \textbf{structures de contrôle} types.
		\end{liste}

		Ce langage repose sur des conventions d’écriture. Il est destiné à
		servir de vecteur de la compréhension permettant par exemple une
		relecture faite par l’élaborateur de l’algorithme lui-même ou faite par
		autrui et facilitant le travail de programmation.

		C’est de cette dernière exigence que nait la polémique consistant à
		savoir jusqu’à quel niveau de détail il convient d’aller dans la
		représentation d’un algorithme ! Nous dirons, pour notre part, qu’il ne
		doit jamais être aussi détaillé que le programme lui-même, celui-ci
		étant, par essence, la description ultime. Point n’est besoin de donner
		deux descriptions quasi identiques d’un algorithme, l’une dans un
		langage \textit{pseudo-codé}, l’autre exprimée dans un langage de
		programmation.

		Nous dirons qu’un algorithme \textit{idéal}, appelé \textbf{algorithme
		général}, exprimé en pseudo-code, devrait se situer à mi-chemin entre
		la démarche globale exprimée dans un langage naturel (langue française)
		ou structuré (ordinogramme) et l’algorithme ultime, c’est-à-dire le
		\textbf{programme}, exprimé en langage de programmation.

		On pourrait d’ailleurs concevoir la possibilité d’établir d’autres
		\textbf{algorithmes plus }\textbf{détaillés} se situant entre
		l’algorithme général et le programme et qui tiendraient compte de
		certaines particularités du langage de programmation dans lequel ils
		sont destinés à être traduits.

		Enfin, et ce n’est pas la chose la moins importante, la définition d’un
		pseudo-code doit être telle qu’il puisse \textbf{faciliter
		l’apprentissage d’une logique de programmation} par des personnes
		désireuses de faire de l’informatique un métier. Dans cette optique, il
		est inutile de les embarrasser de contraintes syntaxiques ou autres qui
		risquent de les éloigner du but poursuivi.

		En conclusion, à partir du moment où des conventions sont prises dans un
		contexte bien déterminé (un service informatique d’une entreprise, un
		groupe scolaire,...), il convient que \textbf{tous }respectent ces
		conventions. Ce sera à chacun de juger jusqu’où il ne faut pas aller
		trop loin dans la liberté d’écriture.

	\section{Variables et types}

		Nous savons que les opérations que l’ordinateur devra exécuter portent
		sur des éléments qui sont les \textbf{données} du problème. Lorsqu’on
		attribue un \textbf{nom} et un \textbf{type} à ces données, on parle
		alors de \textbf{variables}. Dans un algorithme, une variable conserve
		toujours son nom et son type, mais peut changer de \textbf{valeur}.
		
		Le \textbf{nom }d’une variable permet de la caractériser et de la
		reconnaitre. Ainsi, dans l’exemple donné ci-dessus, nous pourrions
		donner le nom \textit{num1} au \textit{premier numérateur} et
		\textit{num2} au \textit{second numérateur}, ce qui permet déjà de
		nommer les objets de l’algorithme de façon tout aussi reconnaissable
		mais plus courte et donc plus commode. Quant au \textbf{type} d’une
		variable, il décrit la nature de son contenu.

		\subsection{Les types autorisés}

			Dans un premier temps, les seuls \textbf{types} utilisés sont les
			suivants :
			
			\begin{center}
			\tablehead{}
			\begin{tabular}[t]{p{2cm}|p{12cm}}
			\raggedleft  \textstyleMotCl{entier} &
			 pour les nombres entiers\\
			\raggedleft  \textstyleMotCl{réel} &
			 pour les nombres réels\\
			\raggedleft  \textstyleMotCl{caractère} &
			 pour les différentes lettres et caractères (par
			exemple ceux qui apparaissent sur un clavier : ‘a’, ‘1’, ‘\#’, etc…)\\
			\raggedleft  \textstyleMotCl{chaine} &
			{ pour les variables contenant plusieurs
			caractères ou aucun}
			
			 (la chaine vide)\\
			\raggedleft  \textstyleMotCl{booléen} &
			 les variables de ce type ne peuvent valoir que
			\textbf{vrai} ou \textbf{faux}\\
			\end{tabular}
			\end{center}
			
			On veillera au cours de logique à ne pas utiliser les valeurs 0 et 1
			pour les variables booléennes, même si leur emploi est correct dans
			beaucoup de langages de programmation.

			
			\begin{Emphase}[exercice]{Exercice : Une date}
				Quel(s) type(s) de données utiliseriez-vous 
				pour représenter une date du calendrier ?
			\end{Emphase}

			
			\begin{Emphase}[exercice]{Exercice : Un moment}
			Quel(s) type(s) de données utiliseriez-vous 
			pour représenter un moment dans la journée ?
			\end{Emphase}

		\subsection{Déclaration de variables}

			La déclaration d’une variable est l’instruction 
			qui définit son nom et son type. On pourrait écrire :

			\cadre{
			\begin{pseudo}
			\Stmt num1 et num2 seront les noms de deux objets destinés à recevoir
			\Stmt les numérateurs des fractions, c’est-à-dire des nombres à valeurs entières.
			\end{pseudo}
			}
			
			Mais, bien entendu, cette formulation, trop proche du
			langage parlé, serait trop floue et trop longue. 
			Dès lors, nous abrégerons par :

			\cadre{
			\begin{pseudo}
			\Declare{num1, num2}{entiers}
			\end{pseudo}
			}

			\marginicon{definition}
			L’ensemble des instructions de la forme

			\cadre{
			\begin{pseudo}
			\Declare{variable1, variable2,\ldots}{type}
			\end{pseudo}
			}

			forme la partie d’un algorithme nommée 
			\textbf{déclaration des variables}. 
			La déclaration des informations apparaitra toujours en
			début d’algorithme, ou dans un bloc annexe appelé 
			\textbf{dictionnaire des variables} 
			ou encore \textbf{dictionnaire des données}.

			Par exemple, pour l’algorithme des fractions, la déclaration des
			informations pourrait être la suivante :

			\cadre{
			\begin{pseudo}
			\Declare{num1, den1, num2, den2, numRes, denRes}{entiers}
			\end{pseudo}
			}

			avec la signification suivante :

			\begin{liste}
			\item
				\textstyleCodeInsr{num1 (num2)} pour numérateur 
				de la première (seconde) fraction ;
			\item
				\textstyleCodeInsr{den1 (den2)} pour dénominateur 
				de la première (seconde) fraction ;
			\item
				\textstyleCodeInsr{numRes (denRes)}
				pour numérateur (dénominateur) du résultat.
			\end{liste}
			
			\marginicon{attention}
			Attention, lors de la déclaration d’une variable, celle-ci n’a pas de
			valeur ! Nous verrons plus loin que c’est l’instruction
			d’\textbf{affectation} qui va servir à donner un contenu aux variables
			déclarées. En logique, nous n’envisageons pas d’\textit{affectation par
			défaut} consistant à donner une valeur initiale de façon automatique
			aux variables déclarées (par exemple 0 pour les variables numériques,
			comme c’est le cas dans certains langages informatiques).

		\subsection{Comment nommer correctement une variable ?}

			Le but est de trouver un nom qui soit suffisamment court tout en restant
			explicite (ainsi \textstyleCodeInsr{num1} est plus approprié pour
			désigner le \textit{premier numérateur }que \textstyleCodeInsr{zozo1},
			\textstyleCodeInsr{tintin}, \textstyleCodeInsr{bidule,
			premierNumérateur}) et qui ne prête pas à confusion (par exemple ne pas
			utiliser un des mots réservés du pseudo-code comme
			\textstyleMotCl{\textsf{lire}}, \textstyleMotCl{\textsf{écrire}},
			\textstyleMotCl{\textsf{pour}}…). Il faut aussi tenir compte que les
			langages de programmation imposent certaines limitations (parfois
			différentes d'un langage à l'autre)
			ce qui peut nécessiter une modification du nom lors de la traduction.

			Voici quelques règles et limitations traditionnelles dans les langages
			de programmation:

			\begin{liste}
			\item 
				Un nom de variable est généralement une suite de caractères
				alphanumériques d’un seul tenant (pas de caractères blancs) et ne
				commençant jamais par un chiffre. Ainsi \textstyleCodeInsr{x1} est
				correct mais non \textstyleCodeInsr{1x}. 
			\item 
				Pour donner un nom composé à une variable, on peut utiliser le «~tiret
				bas~» ou \textit{underscore} (par ex. premier\_numérateur) mais on
				déconseille d’utiliser le signe «~–~» qui est plutôt réservé à la
				soustraction. Ainsi, dans la plupart des langages,
				\textstyleCodeInsr{premier-numérateur} serait interprété comme la
				soustraction des variables \textstyleCodeInsr{premier} et
				\textstyleCodeInsr{numérateur}. (Signalons que le tiret 
				\textcolor{black}{«~–~»} est autorisé en Cobol, où il récupère son rôle
				arithmétique s’il est précédé et suivi d’au moins un blanc).
			\item 
				Une alternative à l’utilisation du tiret bas pour l’écriture de noms de
				variables composés est la notation «~chameau~» (\textit{camelCase} en
				anglais), qui consiste à mettre une majuscule au début des mots
				(généralement à partir du deuxième), par exemple
				\textstyleCodeInsr{premierNombre} ou
				\textstyleCodeInsr{dateNaissance}.
			\item
				Les indices et exposants sont proscrits (par ex.
				\textstyleCodeInsr{x}\textstyleCodeInsr{\textsubscript{1}},
				\textstyleCodeInsr{z}\textstyleCodeInsr{\textsubscript{6}} ou
				\textstyleCodeInsr{m²)}
			\item
				Les mots clés du langage sont interdits (par exemple
				\textstyleMotCl{for}, \textstyleMotCl{if}, \textstyleMotCl{while }pour
				Java et Cobol).
			\item
				Certains langages n’autorisent pas les caractères accentués (tels que
				\textit{à, ç, ê, ø,} etc.) ou les lettres des alphabets non latins
				(tel que ${\Delta}$) mais d’autres oui ; certains font la distinction
				entre les minuscules et majuscules, d’autres non. En logique, nous
				admettons dans noms de variables les caractères accentués du français,
				par ex. : durée, intérêts, etc.
			\end{liste}

			Il est impossible de décrire ici toutes les particularités des
			différents langages, le programmeur se reportera aux règles spécifiques
			du langage qu’il sera amené à utiliser.

			
			\begin{Emphase}[exercice]{Exercice : Déclarer une date}
				Déclarer le(s) variable(s) permettant de représenter la date
				d'anniversaire de quelqu'un.
			\end{Emphase}
			
			
			\begin{Emphase}[exercice]{Exercice : Déclarer un rendez-vous}
				Déclarer le(s) variable(s) permettant de représenter
				l'heure de début, l'heure de fin et
				l'objet d 'un rendez-vous.
			\end{Emphase}

	\section{Opérateurs et expressions}
	
		Les opérateurs agissent sur les variables et les constantes pour former
		des \textbf{expressions}. Une expression est donc une combinaison
		\textbf{cohérente} de variables, de constantes et d’opérateurs,
		éventuellement accompagnés de parenthèses.
	
		\subsection{Opérateurs arithmétiques élémentaires}
	
			Ce sont les opérateurs binaires bien connus :
	
			\begin{center}
			\tablehead{}
			\begin{supertabular}{m{1cm}|m{12cm}}
			\raggedleft  \textstyleCodeInsr{+} & addition\\
			\raggedleft  \textstyleCodeInsr{-} & soustraction\\
			\raggedleft  \textstyleCodeInsr{*} & multiplication\\
			\raggedleft  \textstyleCodeInsr{/} & division réelle\\
			\end{supertabular}
			\end{center}
	
			Ils agissent sur des variables ou expressions à valeurs entières ou
			réelles. Plusieurs opérateurs peuvent être utilisés pour former des
			expressions plus ou moins complexes, en tenant compte des règles de
			calcul habituelles, notamment la priorité de la multiplication et de la
			division sur l’addition et la soustraction. Il est aussi permis
			d’utiliser des parenthèses, par exemple \textstyleCodeInsr{a – (b + c *
			d)/x}. Tout emploi de la division devra être accompagné d’une réflexion
			sur la valeur du dénominateur, une division par 0 entrainant toujours
			l’arrêt d’un algorithme.
	
		\subsection{DIV et MOD}
	
			Ce sont deux opérateurs très importants qui ne peuvent s’utiliser
			qu’avec des variables entières :
	
			\begin{center}
			\tablehead{}
			\begin{supertabular}{m{1cm}|m{12cm}}
			\raggedleft  \textstyleCodeInsr{DIV} & division entière\\
			\raggedleft  \textstyleCodeInsr{MOD} & reste de la division entière\\
			\end{supertabular}
			\end{center}
	
			Par exemple, \textstyleCodeInsr{47 DIV 7} donne 6 tandis que
			\textstyleCodeInsr{47 MOD 7} donne \textstyleCodeInsr{5}.
	
		\subsection{Fonctions mathématiques complexes}
	
			L’élévation à la puissance sera notée \textstyleCodeInsr{**} ou
			\textstyleCodeInsr{\^{}} . Pour la racine carrée d’une variable x nous
			écrirons  $\sqrt{x}$ \textit{.} Attention, pour ce dernier, de veiller
			à ne l’utiliser qu’avec un radicant positif !
	
			\textbf{Exemple} : 
			$(-b+\sqrt{(b\ast \ast 2-4\ast a\ast c)})/(2\ast a)$
			
			Mais on peut aussi accepter la notation mathématique usuelle
			$\frac{-b+\sqrt{b^{2}-4\ast a\ast c}}{2\ast a}$ 
	
			\marginicon{reflexion}
			Pourquoi ne pas avoir écrit «~\textstyleCodeInsr{4ac}~» et
			«~\textstyleCodeInsr{2a}~» ?
	
			Si nécessaire, on se permettra d'utiliser les autres
			fonctions mathématiques sous leur forme la plus courante dans la
			plupart des langages de programmation (exemples :
			\textstyleCodeInsr{sin(x), tan(x), log(2*x), exp(a-b)}, ...)
	
		\subsection{Opérateurs logiques}
	
			Ils agissent sur des expressions booléennes (variables ou expressions à
			valeurs booléennes) pour donner un résultat du même type.
	
			\begin{center}
			\tablehead{}
			\begin{supertabular}{m{1cm}|m{12cm}}
			\raggedleft  \textstyleCodeInsr{NON} & négation\\
			\raggedleft  \textstyleCodeInsr{ET} & conjonction logique\\
			\raggedleft  \textstyleCodeInsr{OU} & disjonction logique\\
			\end{supertabular}
			\end{center}
	
			Pour rappel, \textstyleCodeInsr{cond1 ET cond2} n’est vrai que lorsque
			les deux conditions sont vraies. \textstyleCodeInsr{cond1 OU cond2} est
			toujours vrai, sauf quand les deux conditions sont fausses.
	
			Veillez à mettre des parenthèses dans le cas de combinaisons de ET et de
			OU : \textstyleCodeInsr{(cond1 ET cond2) OU cond3} étant différent de
			\textstyleCodeInsr{cond1 ET (cond2 OU cond3).} En cas
			d'oubli de parenthèses, il faudra se rappeler que
			\textstyleCodeInsr{ET} est prioritaire sur le \textstyleCodeInsr{OU}.
	
		\subsection{Évaluation complète et court-circuitée}
	
			On définit deux modes d’évaluation des opérateurs \textstyleCodeInsr{ET}
			et \textstyleCodeInsr{OU} :
	
			\begin{description}
			\item[l’évaluation \textit{complète}]
				pour connaitre la valeur de
				\textstyleCodeInsr{cond1 ET cond2} (respectivement
				\textstyleCodeInsr{cond1 OU cond2}), les deux conditions sont chacune
				évaluées, après quoi on évalue la valeur de vérité de l’ensemble de
				l'expression.
			\item[l’évaluation \textit{court-circuitée}]
				dans un premier temps, seule la
				première condition est testée. Dans le cas du \textstyleCodeInsr{ET},
				si \textstyleCodeInsr{cond1} s’avère faux, il est inutile d’évaluer
				\textstyleCodeInsr{cond2} puisque le résultat sera faux de toute façon
				; l’évaluation de \textstyleCodeInsr{cond2} et de l’ensemble de la
				conjonction ne se fera que si \textstyleCodeInsr{cond1} est vrai. De
				même, dans le cas du \textstyleCodeInsr{OU}, si
				\textstyleCodeInsr{cond1} s’avère vrai, il est inutile d’évaluer
				\textstyleCodeInsr{cond2} puisque le résultat sera vrai de toute façon
				; l’évaluation de \textstyleCodeInsr{cond2} et de l’ensemble de la
				disjonction ne se fera que si \textstyleCodeInsr{cond1} est faux.
			\end{description}
	
			Dans le cadre de ce cours, nous opterons pour la deuxième définition.
			Montrons sur un exemple l’avantage de cette interprétation. Considérons
			l’expression 
			\textstyleCodeInsr{n }\textstyleCodeInsr{${\neq}$}\textstyleCodeInsr{ 0
			ET s/n {\textgreater} 10}. Si on teste sa valeur de vérité avec une
			valeur de \textstyleCodeInsr{n} non nulle, la première condition est
			vraie et le résultat de la conjonction dépendra de la valeur de la
			deuxième condition. Supposons à présent que \textstyleCodeInsr{n} soit
			nul. L’évaluation court-circuitée donne le résultat \textbf{faux}
			immédiatement après test de la première condition sans évaluer la
			seconde, tandis que l’évaluation complète entrainerait un arrêt de
			l’algorithme pour cause de division par 0 !
	
			Noter que l’évaluation court-circuitée a pour conséquence la
			non-commutativité du \textstyleCodeInsr{ET} et du
			\textstyleCodeInsr{OU~}: \textstyleCodeInsr{cond1 ET cond2} n’est donc
			pas équivalent à \textstyleCodeInsr{cond2 ET cond1}, puisque l’ordre
			des évaluations des deux conditions entre en jeu.~Nous conseillons
			cependant de limiter les cas d’utilisation de l’évaluation
			court-circuitée et d'opter pour des expressions dont
			l’évaluation serait similaire dans les deux cas. La justification
			d’utiliser l’évaluation court-circuitée apparaitra dans plusieurs
			exemples tout au long du cours.
	
		\subsection{Opérateurs de comparaison}
	
			Ces opérateurs agissent généralement sur des variables numériques ou des
			chaines et donnent un résultat booléen.
	
			\begin{center}
			\tablehead{}
			\begin{supertabular}{m{2cm}|m{11cm}}
			\raggedleft  \textstyleCodeInsr{\textless} & (strictement) plus petit que\\
			\raggedleft  \textstyleCodeInsr{\textgreater} & (strictement) plus grand que\\
			\raggedleft  \textstyleCodeInsr{=} & égal\\
			\raggedleft  \textstyleCodeInsr{{\textless}{\textgreater}}
				ou \textstyleCodeInsr{${\neq}$} &  différent de\\
			\raggedleft  \textstyleCodeInsr{${\leq}$} & plus petit ou égal\\
			\raggedleft  \textstyleCodeInsr{${\geq}$} & plus grand ou égal\\
			\end{supertabular}
			\end{center}
	
			Pour les chaines, c'est l’ordre alphabétique qui
			détermine le résultat (par exemple
			\textstyleCodeInsr{{\textquotedbl}milou{\textquotedbl} {\textless}
			{\textquotedbl}tintin{\textquotedbl}} est \textbf{vrai} de même que
			\textstyleCodeInsr{{\textquotedbl}assembleur{\textquotedbl}
			}\textstyleCodeInsr{${\leq}$}\textstyleCodeInsr{
			{\textquotedbl}java{\textquotedbl}})

	\section{L’affectation d’une valeur à une variable}

		Cette opération est probablement l’opération la plus importante. En
		effet, une variable ne prend son sens réel que si elle reçoit à un
		moment donné une valeur. Il y a deux moyens de donner une valeur à une
		variable.

		\subsection{Affectation externe }

			On parle d’\textbf{affectation externe} lorsque la valeur à affecter à
			une variable est donnée par l’utilisateur qui la communique à
			l’exécutant quand celui-ci le lui demande : cette valeur est donc
			\textit{externe} à la procédure \ (l’ordinateur ne peut la deviner
			lui-même !)

			L’affectation externe est donc la primitive qui permet de recevoir de
			l’utilisateur, au moment où l'algorithme se déroule,
			une ou plusieurs valeur(s) et de les affecter à des variables en
			mémoire. Nous noterons :

			\cadre{
			\begin{pseudo}
			\Read liste\_de\_variables\_à\_lire
			\end{pseudo}
			}
			
			{\bfseries Exemples}
			
			\cadre{
			\begin{pseudo}
			\Read nombre1, nombre2
			\Read num1, den1, num2, den2
			\end{pseudo}
			}
			
			L’exécution de cette instruction provoque une
			pause dans le déroulement de l’algorithme : l’exécutant demande alors à
			l’utilisateur les valeurs des variables à lire. Ces valeurs viennent
			donc de l’\textit{extérieur~}; une fois introduites dans le système,
			elles sont affectées aux variables concernées et l’algorithme peut
			reprendre son cours. Par \textit{extérieur} nous entendons ici tout
			support d’introduction des données extérieur à la mémoire du programme.
			Les possibilités sont nombreuses : citons par exemple l’encodage de
			données au clavier, un clic de souris, le toucher d'un
			écran tactile, des données provenant d’un fichier, etc.

		\subsection{Affectation interne }

			On parle d’affectation interne lorsque la valeur d’une variable est
			«~calculée~» par l’exécutant de l’algorithme lui-même à partir de
			données qu’il connait déjà :

			\cadre{
			\begin{pseudo}
			\Let nomVariable \Gets expression
			\end{pseudo}
			}
			
			Rappelons qu’une \textbf{expression} 
			est une combinaison de variables et
			d’opérateurs.
			
			\subsubsection*{Exemples}
			
			\cadre{
			\begin{pseudo}
			\Let somme \Gets nombre1 + nombre2
			\Let denRes \Gets den1 * den2
			\Let cpt \Gets cpt + 1
			\Let delta \Gets b**2 – 4*a*c
			\Let test \Gets a < b \RComment pour une variable logique
			\end{pseudo}
			}

			\subsubsection*{Remarques}

			\begin{liste}
			\item
				Il est de règle que le résultat de l’expression à droite du signe
				d’affectation ($\gets$) soit de
				même type que la variable à sa gauche. On tolère certaines exceptions
				:
				\begin{liste}
				\item
					\textstyleCodeInsr{entier}{ $\gets$ }\textstyleCodeInsr{réel} : 
					dans ce cas le contenu de la variable sera la valeur tronquée
					de l’expression réelle. 
					Par exemple si «~\textstyleCodeInsr{nb}~» est
					une variable de type entier, son contenu après l’instruction
					«~\textstyleCodeInsr{nb}{ $\gets$ }\textstyleCodeInsr{$15/4$}~» 
					sera 3
				\item 
					\textstyleCodeInsr{réel}{ $\gets$ }\textstyleCodeInsr{entier} :
					ici, il n'y a évidemment pas de perte de valeur.
				\item 
					\textstyleCodeInsr{chaine}{ $\gets$ }\textstyleCodeInsr{caractère} : 
					le contraire n'est évidemment pas accepté.
				\end{liste}
			\item 
				Seules les variables déclarées peuvent être affectées, que ce soit par
				l’affectation externe ou interne!
			\item 
				On veillera à ne pas mélanger la déclaration d’une variable et son
				affectation interne dans une même ligne de code, donc pas
				d’instructions hybrides du genre 
				\textsf{x}{ $\gets$ }\textstyleCodeInsr{2 : entier}
			\item 
				Pour l’affectation interne, toutes les variables apparaissant dans
				\textstyleCodeInsr{expression} doivent avoir été affectées
				préalablement. Le contraire provoquerait un arrêt de l’algorithme.
			\end{liste}
			
	\section{Communication des résultats}

		L’instruction de communication des résultats consiste à donner à
		l’extérieur (donc à l’utilisateur) la valeur d’un résultat de
		l’exécution de l’algorithme. Nous écrirons :

			\cadre{
			\begin{pseudo}
			\Write expression ou liste de variables
			\end{pseudo}
			}

		qui signifie que la valeur d’une expression (ou celles des différentes
		variables mentionnées) sera fournie à l’utilisateur (par exemple par un
		affichage à l’écran ou par impression sur listing via l’imprimante,
		etc\dots).

		\subsubsection*{Remarques}

		\begin{liste}
		\item
			Ce ne serait pas une erreur fondamentale de remplacer
			\textstyleCodeInsr{lire} par \textstyleCodeInsr{recevoir} ou
			\textstyleCodeInsr{écrire} par \textstyleCodeInsr{afficher}. Il n’y a
			évidemment pas de confusion possible à partir du moment où l’on sait
			qu’il s’agit de primitives d’échange entre l’extérieur et l’ordinateur
			exécutant la procédure, mais par principe, il est conseillé d’utiliser
			une syntaxe commune et limitée à un petit nombre de mots clés.
		\item
			Comme pour l’affectation interne, on ne peut \textstyleCodeInsr{écrire}
			que des expressions dont les variables ont été affectées préalablement.
		\end{liste}

	\section{Structure générale d’un algorithme}

		La traduction d’un algorithme en pseudo-code constituera le contenu d’un
		\textstyleMotCl{module}. Un module contient donc la solution
		algorithmique d’un problème donné (ou d’une de ses parties). Sa
		structure générale sera la suivante :

		\cadre{
		\begin{pseudo}
		\Module{nomDuModule}{}{}
			\Stmt \textit{déclaration des variables et constantes utilisées dans le module}
			\Stmt \textit{lecture des données}
			\Stmt \textit{instructions utilisant les données lues}
			\Stmt \textit{communication des résultats}
		\EndModule
		\end{pseudo}
		}		

		\subsubsection*{Remarques}
		
		\begin{liste}
		\item {
			Le code d'un algorithme sera toujours compris entre la
			première ligne ; appelée «~entête~» qui commence par le mot «~module~»
			suivi du nom choisi pour l'algorithme ; et la ligne
			finale «~fin module~». Le code compris entre l'entête
			et la ligne finale sera toujours légèrement décalé vers la droite,
			c'est un premier exemple
			d'\textbf{indentation} indispensable pour la
			lisibilité d'un programme, nous y reviendrons lors de
			l'étude des structures alternatives et répétitives.}
		\item {
			Comme pour les variables, le nomDuModule devra être approprié au contenu
			! Par exemple, sommeNombres, additionnerFractions plutôt que goPartez
			!
			Le rôle des parenthèses qui suivent le nom du module sera expliqué plus
			tard.}
		\item {
			Il va de soi que toutes les parties de cette structure générale ne
			seront pas toujours nécessaires : certains algorithmes ne nécessiteront
			pas de lecture de données, d'autres ne devront pas
			communiquer des résultats,...}
		\item {
			Pour la lisibilité, on veillera toujours à ce qu'un module
			tienne sur une seule page.}
		\end{liste}

		À titre d’exemple, récrivons l’algorithme d’addition de fractions décrit
		en début de chapitre :

		\cadre{
		\begin{pseudo}
		\Module{additionnerFractions}{}{}
			\Declare{num1, den1, num2, den2, numRes, denRes}{entiers}
			\Read num1, den1, num2, den2
			\Let denRes \Gets den1 * den2
			\Let numRes \Gets num1*den2 + num2*den1
			\Write numRes, "/", denRes
		\EndModule
		\end{pseudo}
		}

	\section{Commenter un algorithme}

		On n’insistera jamais assez sur la nécessité de \textbf{documenter} un
		algorithme en y insérant des \textbf{commentaires} judicieux, clairs et
		suffisants ! Un commentaire est un texte placé dans
		l'algorithme et destiné à faciliter au maximum la
		compréhension d’un algorithme par le lecteur (parfois une autre
		personne, mais aussi souvent l'auteur qui se perd dans
		son propre texte lorsqu'il y replonge après une
		interruption). Ces commentaires (introduits par
		«~\textstyleCodeInsr{//~» }) seront bien entendu ignorés par
		l’exécutant de l’algorithme.

		\cadre{
		\begin{pseudo}
		\LComment Ce module lit les contenus de 2 fractions et affiche leur somme
		\Module{additionnerFractions}{}{}
			\Declare{num1, den1, num2, den2, numRes, denRes}{entiers}
			\Read num1, den1, num2, den2
			\Let denRes \Gets den1 * den2
				\RComment calcul du dénominateur
			\Let numRes \Gets num1*den2 + num2*den1
				\RComment calcul du numérateur
			\Empty \RComment la fraction n'est sans doute pas simplifiée
			\Write numRes, "/", denRes
		\EndModule
		\end{pseudo}
		}

		Noter qu’un excès de commentaires peut être aussi nuisible qu’un
		trop-peu pour la compréhension d’un algorithme. Par exemple, un choix
		judicieux de noms de variables peut s’avérer bien plus efficace que des
		commentaires superflus. Ainsi, l’instruction

		\cadre{
		\begin{pseudo}
		\Let nouveauCapital \Gets ancienCapital * (1 + taux / 100)
		\end{pseudo}
		}

		dépourvue de commentaires est bien préférable aux lignes suivantes :

		\cadre{
		\begin{pseudo}
		\Let c1 \Gets c0 * (1 + t / 100) \RComment calcul du nouveau capital
		\Empty \RComment c1 est le nouveau capital, c0 est l’ancien capital, t est le taux
		\end{pseudo}
		}

	\section{Compléments de pseudo-code}

		\textstyleMotCl{\textmd{Présentons quelques notions algorithmiques peu
		utilisées en première mais qui vous seront peut-être utiles dans
		l'un ou l'autre des exercices.}}

		\subsection{Constantes}

			Une \textbf{constante} est une information pour laquelle nom, type et
			valeur sont figés. La liste des constantes utilisées dans un algorithme
			apparaitra dans la section déclaration des variables sous la forme
			suivante :

			\cadre{
			\begin{pseudo}
			\Stmt \K{constante} PI = 3,14
			\Stmt \K{constante} ESI 
				= {\textquotedbl}École Supérieure d’Informatique{\textquotedbl}
			\end{pseudo}
			}

			\textstyleMotCl{\textmd{Il est inutile de spécifier leur type, celui-ci
			étant défini implicitement par la valeur de la constante.}}

		\subsection{Énumération}

			Parfois, une variable ne peut prendre qu'un ensemble
			fixe et fini de valeurs. Par exemple une variable représentant une
			saison ne peut prendre que quatre valeurs (HIVER, PRINTEMPS, ETE,
			AUTOMNE). On va l'indiquer grâce à
			l'énumération qui introduit un \textbf{nouveau type}
			de donnée.

			\cadre{
			\begin{pseudo}
			\Stmt \K{énumération} Saison \{ HIVER, PRINTEMPS, ETE, AUTOMNE \}
			\end{pseudo}
			}

			Il y a deux avantages à cela : une indication claire des possibilités de
			la variable lors de la déclaration et une lisibilité du code grâce à
			l'utilisation des valeurs explicites.

			
			\begin{Emphase}[exercice]{Exercice : Autres situations}

				Pouvez-vous identifier d'autres données qui pourraient
				avantageusement s'exprimer avec une énumération ?

			\end{Emphase}
			
			\subsubsection*{Quid des langages de programmation ?}

				Certains langages (comme Java) proposent un type énuméré complet.
				D'autres (comme C et C++) proposent un type énuméré
				incomplet mais qui permet néanmoins une écriture comme celle ci-dessus.
				Cobol propose des «~noms conditions~» qui représentent
				l'ensemble des valeurs possibles
				d'une variable. D'autres langages,
				enfin, ne proposent rien. Pour ces langages, le truc est de définir des
				constantes entières qui vont permettre une écriture proche de celle
				ci-dessus (mais sans une déclaration explicite).

			\subsubsection*{Lien avec les entiers}

				Dans l'exemple ci dessus, on lit un Mois mais souvent
				on disposera plutôt d'un entier. Il faut pouvoir
				convertir les valeurs. Chaque langage de programmation propose sa
				propre technique; nous allons adopter la syntaxe suivante :

				\cadre{
				\begin{pseudo}
				\Stmt Mois(3) 
					\RComment donne l'énumération du mois numéro 3 (on commence à 1)
				\Stmt Entier(mois)
					\RComment donne l'entier associé à un mois					
				\end{pseudo}
				}

	\section{Exercices}

		\subsection{Pour s'échauffer}

\begin{Exercice}{Compréhension d'algorithme}

	Pour ces exercices, on vous demande de comprendre des algorithmes
	donnés. Plus précisément, que vont-ils afficher si à chaque fois les
	deux nombres lus au départ sont successivement $2$ et $3$ ?

	\cadre{
	\begin{pseudo}
	\Module{exerciceA}{}{}
		\Decl a,b : entiers
		\Read a,b
		\Let a \Gets a + 2 * b
		\Write a
	\EndModule
	\end{pseudo}
	}

	\cadre{
	\begin{pseudo}
	\Module{exerciceB}{}{}
		\Decl a,b : entiers
		\Decl quotient : réel
		\Read b,a
		\Let quotient \Gets a / b
		\Write quotient
	\EndModule
	\end{pseudo}
	}

	\cadre{
	\begin{pseudo}
	\Module{exerciceC}{}{}
		\Decl a,b,c,d : entiers
		\Read c,d
		\Let a \Gets 2 * c + 5 * d
		\Let b \Gets 2 + c * 3 + d
		\Let c \Gets a MOD b 
		\Write a DIV c
	\EndModule
	\end{pseudo}
	}

	\cadre{
	\begin{pseudo}
	\Module{exerciceD}{}{}
		\Decl x,y : réels
		\Read x,y
		\Let x \Gets x * x
		\Let x \Gets x * x + y * y
		\Let x \Gets ${\surd}$(x) 
		\Write x
	\EndModule
	\end{pseudo}
	}

	\cadre{
	\begin{pseudo}
	\Module{exerciceE}{}{}
		\Decl x,y : réels
		\Read x,x
		\Let x \Gets x MOD x + (x + 1) DIV 2
		\Write x + 3
	\EndModule
	\end{pseudo}
	}

\end{Exercice}

\begin{Exercice}{Le jeu des $n$ erreurs}

	Pouvez-vous identifier les erreurs et/ou les
	problèmes dans les modules suivants ?

	\cadre{
	\begin{pseudo}
	\Module{exA}{}{} \Comment Division
		\Decl nb1, nb2 : réels
		\Write nb1 / nb2
	\EndModule
	\end{pseudo}
	}

	\cadre{
	\begin{pseudo}
	\Module{exB}{}{} \Comment Somme
		\Decl nb1, nb2 : réels
		\Read nb1, nb2
		\Let m \Gets (nb1 + nb2) / 2
		\Write m
	\EndModule
	\end{pseudo}
	}

\end{Exercice}

\begin{Exercice}{Simplification d'algorithme}

	Voici quelques extraits d’algorithmes corrects du point de vue de la
	syntaxe mais contenant des lignes inutiles ou des lourdeurs d’écriture.
	Remplacer chacune de ces portions d’algorithme par un minimum
	d’instructions qui auront un effet équivalent.

	\cadre{
	\begin{pseudo}
	\Let hauteur \Gets largeur * 50 \Comment les deux variables sont des entiers
	\Let hauteur \Gets hauteur MOD 5 + 7
	\end{pseudo}
	}

	\cadre{
	\begin{pseudo}
	\Read var
	\Let var \Gets 0
	\end{pseudo}
	}

	\cadre{
	\begin{pseudo}
	\Let var \Gets 0
	\Read var
	\end{pseudo}
	}

	\cadre{
	\begin{pseudo}
	\Let ok2 \Gets NON (ok1 = vrai) ET NON (ok1 = faux)

	\end{pseudo}
	}

\end{Exercice}

\subsection{Exercices d’apprentissage}

	Il est temps de se lancer et d'écrire vos premiers
	modules. Voici de précieux conseils pour vous guider dans la résolution
	de tels problèmes.

	\begin{liste}
	\item {
		il convient d’abord de bien comprendre le problème posé; assurez-vous
		qu’il est parfaitement spécifié ;}
	\item {
		déclarez ensuite les variables (et leur type) qui interviennent dans
		l’algorithme ; les noms des variables risquant de ne pas être
		suffisamment explicites, donnez les renseignements nécessaires à la
		compréhension de l’existence de ces variables ;}
	\item {
		mettez en évidence les variables «~données~», les variables
		«~résultats~» et les variables de travail ;}
	\item {
		n’hésitez pas à faire une ébauche de résolution en français avant
		d’élaborer l’algorithme définitif pseudo-codé.}
	\end{liste}

\begin{Exercice}{Surface d'un triangle}
	\marginicon{java}
	Écrire un algorithme qui calcule et affiche la surface
	d'un triangle connaissant sa base et sa hauteur.
\end{Exercice}

\begin{Exercice}{Placement}
	Écrire un algorithme qui, étant donné le montant d’un capital placé (en
	€) et le taux d’intérêt annuel (en \%), calcule et affiche la valeur
	totale acquise après un an de ce placement.
\end{Exercice}

\begin{Exercice}{Prix TTC}
	Écrire un algorithme qui, étant donné le prix unitaire d’un produit
	(hors TVA), le taux de TVA (en \%) et la quantité de produit vendue à
	un client, calcule et affiche le prix total à payer par ce client.
\end{Exercice}

\begin{Exercice}{Durée de trajet}
	Écrire un algorithme qui, étant donné la vitesse moyenne en \textbf{m/s}
	d’un véhicule et la distance parcourue en \textbf{km} par ce véhicule,
	calcule et affiche la durée en secondes du trajet de ce véhicule.
\end{Exercice}

\begin{Exercice}{Permutation}
	\marginicon{java}
	Écrire une séquence d’instructions qui réalise la permutation du contenu
	de deux variables.
\end{Exercice}

\begin{Exercice}{Cote moyenne}
	Écrire un algorithme qui, étant donné les résultats (cote entière sur
	20) de trois examens passés par un étudiant (exprimés par six nombres,
	à savoir, la cote et la pondération de chaque examen) calcule et
	affiche la moyenne globale exprimée en pourcentage. Vérifiez bien votre
	algorithme avec des valeurs concrètes; il est facile de se tromper dans
	la formule !
\end{Exercice}

\begin{Exercice}{Somme des chiffres}
	\marginicon{java}
	Écrire un algorithme qui calcule la somme des chiffres
	d'un nombre entier de 3 chiffres.
	Réflexion : l’algorithme est-il aussi valide pour les entiers inférieurs
	à 100 ?
\end{Exercice}

\begin{Exercice}{Conversion HMS en secondes}
	\marginicon{java}
	Écrire un algorithme qui, étant donné un moment dans la journée donné
	par trois nombres lus, à savoir, heure, minute et seconde, calcule le
	nombre de secondes écoulées depuis minuit.
\end{Exercice}

\begin{Exercice}{Conversion secondes en HMS}
	\marginicon{java}
	Écrire un algorithme qui, étant donné un temps écoulé dans la journée
	exprimé en secondes, calcule et affiche ce temps sous la forme de trois
	nombres (heure, minute et seconde).

	Ex : 10000 secondes donnera 2h 46'40''
\end{Exercice}
